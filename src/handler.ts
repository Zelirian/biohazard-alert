import { Context, Logger } from 'probot'; // eslint-disable-line no-unused-vars

import Analyzer from './analyzer';
import Notifier from './notifier';

/**
 * Configuration information.
 */
interface Config {
  /** Flag indicating whether to ignore events from private repos. */
  skipPrivateRepos: boolean;

  /** Value over which to send a notification. Ranges from [0,1]. */
  threshold: number;
}

type GetConfig = (
  context: Context,
  filename: string,
  defaults: Config
) => Config;

const getConfig = require('probot-config') as GetConfig;

const defaults = {
  skipPrivateRepos: true,
  threshold: 0.8
};

/**
 * Handles events received by Probot.
 */
export default class Handler {
  /** Used to analyze events */
  private analyzer: Analyzer;

  /** Probot logger */
  private log: Logger;

  /** Used to send notifications of analysis */
  private notifier: Notifier;

  constructor(logger: Logger) {
    this.analyzer = new Analyzer(logger);
    this.log = logger;
    this.notifier = new Notifier(logger);
  }

  /**
   * Handles an event described by `context`.
   */
  async handle(context: Context): Promise<void> {
    const config = await getConfig(context, 'biohazard-alert.yml', defaults);
    const info = this.parseContext(context);

    if (!info) {
      this.log.info(
        `Skipping unhandleable event: ${context.event}.${context.payload.action}`
      );

      return;
    }

    if (info.isRepoPrivate && config.skipPrivateRepos) {
      this.log.info(`Skipping event in private repository ${info.source}`);

      return;
    }

    if (info.isBot) {
      this.log.info(`Skipping event generated by a bot ${info.source}`);

      return;
    }

    let scores;

    try {
      scores = await this.analyzer.analyze(info);
    } catch (e) {
      this.notifier.notifyError(info, e.error.error.message, e.message);

      throw e;
    }

    for (let attr in scores) {
      this.log.info(`Model ${attr} score ${scores[attr]} for ${info.source}`);
    }

    const thresholdScores = this.isOverThreshold(scores, config.threshold);

    if (thresholdScores) {
      this.notifier.notify(info, thresholdScores);
    }
  }

  /**
   * Determines whether any of the `scores` are over the `threshold`.
   *
   * Returns only the scores that exceed the threshold or `null` if none of them did.
   */
  private isOverThreshold(scores: Scores, threshold: number): Scores | null {
    let thresholdScores: Scores = {};
    let crossedThreshold = false;

    for (let attr in scores) {
      if (scores[attr] >= threshold) {
        thresholdScores[attr] = scores[attr];
        crossedThreshold = true;
      }
    }

    return crossedThreshold ? thresholdScores : null;
  }

  /**
   * Parses the important bits out of `context`.
   *
   * Returns an `EventInfo` structure or `null` if the event represented is not supported.
   */
  private parseContext(context: Context): EventInfo | null {
    const fullEvent = `${context.event}.${context.payload.action}`;

    switch (fullEvent) {
      case 'issues.opened':
      case 'issues.edited':
        return {
          author: context.payload.issue.user.login,
          event: context.event,
          fullEvent: fullEvent,
          isBot: context.isBot,
          isRepoPrivate: context.payload.repository.private,
          source: context.payload.issue.html_url,
          content:
            '# ' +
            context.payload.issue.title +
            '\n\n' +
            context.payload.issue.body
        };

      case 'commit_comment.created':
        return {
          author: context.payload.comment.user.login,
          event: context.event,
          fullEvent: fullEvent,
          isBot: context.isBot,
          isRepoPrivate: context.payload.repository.private,
          source: context.payload.comment.html_url,
          content: context.payload.comment.body
        };

      case 'issue_comment.created':
      case 'issue_comment.edited':
        return {
          author: context.payload.comment.user.login,
          event: context.event,
          fullEvent: fullEvent,
          isBot: context.isBot,
          isRepoPrivate: context.payload.repository.private,
          source: context.payload.comment.html_url,
          content: context.payload.comment.body
        };

      default: {
        return null;
      }
    }
  }
}
