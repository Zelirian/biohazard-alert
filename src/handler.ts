import { Context, Logger } from 'probot' // eslint-disable-line no-unused-vars

import Analyzer from './analyzer'
import Notifier from './notifier'

interface Config {
  skipPrivateRepos: boolean
  threshold: number
}

type GetConfig = (context: Context, filename: string, defaults: Config) => Config
type Scores = {[s: string]: number}

const getConfig = require('probot-config') as GetConfig

const defaults = {
  skipPrivateRepos: true,
  threshold: 0.8
}

/**
 * Handles events received by Probot.
 */
export default class Handler {
  /** Used to analyze events */
  private analyzer: Analyzer

  /** Probot logger */
  private log: Logger

  /** Used to send notifications of analysis */
  private notifier: Notifier

  constructor (logger: Logger) {
    this.analyzer = new Analyzer(logger)
    this.log = logger
    this.notifier = new Notifier(logger)
  }

  /**
   * Handles an event described by `context`.
   */
  async handle (context: Context): Promise<void> {
    const config = await getConfig(context, 'biohazard-alert.yml', defaults)
    const info = this.parseContext(context)

    if (!info) {
      this.log.info(`Skipping unhandleable event: ${context.event}.${context.payload.action}`)

      return
    }

    if (info.isRepoPrivate && config.skipPrivateRepos) {
      this.log.info(`Skipping event in private repository ${info.source}`)

      return
    }

    if (info.isBot) {
      this.log.info(`Skipping event generated by a bot ${info.source}`)

      return
    }

    let scores

    try {
      scores = await this.analyzer.analyze(info)
    } catch (e) {
      this.notifier.notifyError(info, e.error.error.message, e.message)

      throw e
    }

    for (let attr in scores) {
      this.log.info(`Model ${attr} score ${scores[attr]} for ${info.source}`)
    }

    const thresholdScores = this.isOverThreshold(scores, config.threshold)

    if (thresholdScores) {
      this.notifier.notify(info, thresholdScores)
    }
  }

  private isOverThreshold (scores: Scores, threshold: number): Scores | null {
    let thresholdScores: Scores = {}
    let crossedThreshold = false

    for (let attr in scores) {
      if (scores[attr] >= threshold) {
        thresholdScores[attr] = scores[attr]
        crossedThreshold = true
      }
    }

    return crossedThreshold ? thresholdScores : null
  }

  private parseContext (context: Context): EventInfo | null {
    const fullEvent = `${context.event}.${context.payload.action}`

    switch (fullEvent) {
      case 'issues.opened':
      case 'issues.edited':
        return {
          author: context.payload.issue.user.login,
          event: context.event,
          fullEvent: fullEvent,
          isBot: context.isBot,
          isRepoPrivate: context.payload.repository.private,
          source: context.payload.issue.html_url,
          content: '# ' + context.payload.issue.title + '\n\n' + context.payload.issue.body
        }

      case 'commit_comment.created':
        return {
          author: context.payload.comment.user.login,
          event: context.event,
          fullEvent: fullEvent,
          isBot: context.isBot,
          isRepoPrivate: context.payload.repository.private,
          source: context.payload.comment.html_url,
          content: context.payload.comment.body
        }

      case 'issue_comment.created':
      case 'issue_comment.edited':
        return {
          author: context.payload.comment.user.login,
          event: context.event,
          fullEvent: fullEvent,
          isBot: context.isBot,
          isRepoPrivate: context.payload.repository.private,
          source: context.payload.comment.html_url,
          content: this.stripEmailReply(context.payload.comment.body)
        }

      default: {
        return null
      }
    }
  }

  private stripEmailReply (content: string): string {
    const replyBlockPattern = /(^.*<[^@]+@[^>]+>.*:$\n\n)?(^>.*$\n?)+/m
    const match = replyBlockPattern.exec(content)

    return match ? content.slice(0, match.index) : content
  }
}
